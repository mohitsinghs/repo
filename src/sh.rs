use std::{path::Path, process::exit};

pub fn get_current_shell() -> Option<String> {
    match std::env::var("SHELL") {
        Ok(shell) => Path::new(&shell)
            .file_name()
            .and_then(|f| f.to_str())
            .map(|f| f.to_string()),
        Err(_) => None,
    }
}

pub fn print_completions(shell: Option<&str>, binding: &str) {
    match shell {
        Some("zsh") => println!(
            "# Put the line below in ~/.zshrc:
#
#   eval \"$(repo sh zsh -b {binding})\"
#
# The following lines are autogenerated:

__repo_completion() {{
    reply=($(repo cmp $@))
}}

{binding}() {{
    local p=\"$(repo cd $@)\"
    test -d \"$p\" && cd \"$p\"
}}

compctl -U -K __repo_completion {binding}",
        ),
        Some("bash") => println!(
            "# Put the line below in ~/.bashrc or ~/.bash_profile:
#
#   eval \"$(repo sh bash -b {binding})\"
#
# The following lines are autogenerated:

__repo_completion() {{
	local term=\"${{COMP_LINE/#{binding} /}}\"
	COMPREPLY=($(repo cmp \"$term\"))
}}

{binding}() {{
    local p=\"$(repo cd $@)\"
    test -d \"$p\" && cd \"$p\"
}}

complete -o dirnames -F '__repo_completion' {binding}",
        ),
        Some(sh) => {
            println!("unsupported shell : {}", sh);
            exit(1)
        }
        None => exit(0),
    }
}
